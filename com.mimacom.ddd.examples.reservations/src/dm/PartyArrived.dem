domain dm.Restaurant 
import dm.Restaurant.Reservations
import dm.Restaurant.Reservations.Party
import dm.Restaurant.Reservations.PartyState
import dm.Restaurant.Reservations.TableState

event Party_Arrived 
«A group of people (a.k.a. [Party]) have entered the restaurant and request a [Table] for a [[Party#size|number]] of persons.»
{

	context
		p : Party

	triggered by
		Leader_of_Party
		Waiter
	
	notifications
		Please_Have_A_Seat : Message to Leader_of_Party
		Please_Wait_at_the_Bar : Message to Leader_of_Party

	preconditions
		Party_Just_Arrived:
			p.state != Party.ARRIVED AND p.arrival_Time = now()

		Party_Not_At_Table:
			NOT Table.all.exists(t | t.party = p)

	postconditions
		case Party_At_Table
		when Tables.has_Free_Table(p.size):

			Party_Seated:
				p.state = Party.SEATED

			Party_Assigned_To_Table:
				Table.all.exists(t | t.seats ≥ p.size AND t.party = p AND t.state = Table.USED)

			Message_Delivered:
				Please_Have_A_Seat.delivered

		case Party_Waiting
		when p.max_Wait_Time ≤ Tables.estimated_Wait_Time(p.size) AND NOT Tables.has_Free_Table(p.size) :

			Party_Waiting:
				p.state = Party.WAITING AND p.arrival_Time = now()

			Message_Delivered:
				Please_Wait_at_the_Bar.delivered

		case Party_Left
		when p.max_Wait_Time > Tables.estimated_Wait_Time(p.size):

			Party_Left:
				p.state = Party.LEFT
}


